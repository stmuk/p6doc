=begin pod

=TITLE Ruby To Perl6 - Nutshell

=SUBTITLE Ruby to Perl 6, in a nutshell: How do I do what I used to do?

This page attempts to index the changes in syntax and semantics from
Ruby to Perl 6. Whatever worked in Ruby and must be written differently
in Perl 6, should be listed here (whereas many I<new> Perl 6 features and
idioms won't be).

Hence this should not be mistaken for a beginner tutorial or a promotional
overview of Perl 6; it is intended as a technical reference for Perl 6
learners with a strong Ruby background and for anyone porting Ruby code
to Perl 6 (though note that L<#Automated Translation> might be more
convenient).

A note on semantics; when we say "now" in this document, we mostly just
mean "now that you are trying out Perl 6."  We don't mean to imply that
Ruby is now suddenly obsolete. Quite the contrary, most of us love
Ruby, and we expect Ruby to continue in use for a good many years.
Indeed, one of our more important goals has been to make interaction between
Ruby and Perl 6 run smoothly. However, we do also like the design
decisions in Perl 6, which are certainly newer and arguably better
integrated than many of the historical design decisions in Ruby.
So many of us do hope that over the next decade or two, Perl 6 will
become the more dominant language. If you want to take "now" in that
future sense, that's okay too. But we're not at all interested in the
either/or thinking that leads to fights.


=head2 RubyGems

See L<https://modules.perl6.org/> .

If the module that you were using has not been converted to Perl 6, and no
alternative is listed in this document, then its use under Perl 6 may not
have been addressed yet.

There are multiple projects aiming to make it possible to C<use> Ruby
modules directly from Perl 6 code:

=defn  L<Inline::Ruby|https://github.com/awwaiid/Inline-Ruby/>
Uses an embedded instance of the C<ruby> interpreter to run Ruby code
called from your Perl 6 script.

Of these, Inline::Ruby is currently the furthest along and the most
promising.


=head2 Syntax

=head3 C«.» Method calls

If you've read any Perl 6 code at all, it's immediately obvious that
method call syntax now uses a dot just like Ruby:

    person.name    # Ruby
    $person.name   # Perl 6

To call a method whose name is not known until runtime:

    object.send(methodname, args);  # Ruby
    $object."$methodname"(@args);   # Perl 6

If you leave out the quotes, then Perl 6 expects C<$methodname> to contain
a C<Method> object, rather than the simple string name of the method.

=head3 Whitespace

Ruby allows a surprising amount of flexibility in the use of whitespace,
even with strict mode and warnings turned on:

    # unidiomatic but valid Ruby
    puts"Hello "+
    (people [ i]
        . name
        ) . upcase+"!"if$greeted[i]<1

Perl 6 also endorses programmer freedom and creativity, but balanced syntactic
flexibility against its design goal of having a consistent, deterministic,
extensible grammar that supports single-pass parsing and helpful error
messages, integrates features like custom operators cleanly, and doesn't lead
programmers to accidentally misstate their intent. Also, the practice of "code
golf" is slightly de-emphasized; Perl 6 is designed to be more concise in
concepts than in keystrokes.

As a result, there are various places in the syntax where whitespace is
optional in Ruby, but is either mandatory or forbidden in Perl 6. Many of those
restrictions are unlikely to concern much real-life Perl code (e.g. whitespace
being disallowed between an array variable and its square braces), but there
are a few that will unfortunately conflict with some Ruby hackers' habitual
coding styles:

=begin item
I<No space allowed before the opening parenthesis of an argument list.>

    foo (3, 4, 1); # Not right in Ruby or Perl 6 (in Perl 6 this would
                   # try to pass a single argument of type List to foo)
    foo(3, 4, 1);  # Ruby and Perl 6
    foo 3, 4, 1;   # Ruby and Perl 6 - alternative parentheses-less style

=end item

=begin item
I<Space is B<required> immediately after keywords>

    if(a < 0); ...; end         # OK in Ruby
    if ($a < 0) { ... }         # Perl 6
    if $a < 0 { ... }           # Perl 6, more idiomatic

    while(x > 5); ...; end      # OK in Ruby
    while ($x > 5) { ... }      # Perl 6
    while $x > 5 { ... }        # Perl 6, more idiomatic

=end item

=begin item
I<No space allowed before a postfix/postcircumfix operator (including
array/hash subscripts).>

    seen [ :fish ] = 1    # Ruby, not idiomatic but allowed
    %seen{ :fish } = 1;   # Perl 6, no space allowed after 'seen'
=end item

=begin item
I<Space required before an infix operator if it would
conflict with an existing postfix/postcircumfix operator.>

    n<1     # Ruby (in Perl 6 this would conflict with postcircumfix < >)
    $n < 1; # Perl 6

=end item

=head3 Statement Ending Semi-Colons

Ruby detects the end of most statements with a newline (and a few exceptions),
as long as the expression is complete. It is common break up a long expression
by leaving an operator dangling at the end of a line to ensure that the parsing
will continue:

    foo +     # In Ruby a trailing operator means parsing should continue
      bar +
      baz

In Perl 6 you must explicitly terminate statements with a C<;>, which allows
for better feedback and more flexibility in breaking up long lines. Two
exceptions not needing an explicit C<;> are the last statement in a block, and
after the closing curley brace of the block itself (if there is nothing else on
that line):

    if 5 < $x < 10 {
      say "Yep!";
      $x = 17         # No ; required before closing }
    }                 # No ; required after closing } because of the newline
    say "Done!";      # The ; is not required here if nothing follows

=head3 Sigils

In Ruby, variables use sigils primarily to indicate scope. C<$> for global
scope, C<@@> for class scope, C<@> for instance scope, and no sigil for local
variables (including parameters). The C<&> sigil is also used to indicate
method references. Symbols are prefixed with C<:>, but they are not variable
and so not really sigils.

In Perl 6 sigils are primarily used to indicate a role that the contained value
implements, indicating the type (or at least the interface) of the value. The
sigils are invariant, no matter how the variable is being used - you can think
of them as part of the variable's name.

The scope of a variable is instead indicated by the declaration itself (C<my>,
C<has>, C<our>, etc).

(See also L<#Dereferencing>).

=head4 C<$> Scalar

The C<$> sigil is always used with "scalar" variables (e.g. C<$name>). These
are single-value containers.

This is the most general-purpose variable type, with no restrictions on its
contents. Note that you can still address/use its contents, like C<$x[1]>,
C<$x{"foo"}>, and C<$f("foo")>.

=head4 C<@> Array

The C<@> sigil is always used with "array" variables (e.g. C<@months>,
C<@months[2]>, C<@months[2, 4]> for an array slice).

=head4 C<%> Hash

The C<%> sigil is always used with "hash" variables (e.g. C<%calories>,
C<%calories<apple>>, C<%calories<pear plum>>).

=head4 C<&> Sub

TODO: This section isn't quite right

The C<&> sigil is used very similarly to Ruby's C<&> to refer to the function
object of a named subroutine/operator without invoking it, i.e. to use the name
as a "noun" instead of a "verb":

    foo_method = &foo;     # Ruby
    my &foo_method = &foo; # Perl 6

    callback: &say  # Ruby
    callback => &say            # Perl 6 - & gives "noun" form of any sub

Since Perl 6 does not allow adding/removing symbols in a lexical scope once
it has finished compiling, there is no equivalent to Ruby's
C<undef &foo;>, and the closest equivalent to Ruby's C<defined &foo>
would be C<defined &::("foo")> (which uses the "dynamic symbol lookup"
syntax). However, you can declare a mutable named subroutine with
C<my &foo;> and then change its meaning at runtime by assigning to C<&foo>.

In Ruby, the ampersand sigil can additionally be used to call subroutines
in special ways with subtly different behavior compared to normal sub
calls. In Perl 6 those special forms are no longer available:

=head4 C<*> Slurpy params / argument expansion

In Ruby you can declare a parameter to slurp the remainder of the passed
arguments into an array using a C<*> prefix. It works the same way in Perl 6:

    def foo(*args); puts "I got #{args.length} args!"; end # Ruby
    sub foo(*@args) { say "I got #{@args.elems} args!" }   # Perl 6

You might want to expand an array into a set of arguments. In Perl 6 this is
done using the C<|> prefix:

    args = %w(a b c)         # Ruby
    foo(*args)

    my @args = <a b c>       # Perl 6
    foo(|@args)

=head3 Twigils

Perl 6 additionally uses "twigils", which are further indicators about the
variable and go between the sigil and the rest of the variable name. Examples:

    $foo     # Scalar with no twigil
    $!foo    # Private instance variable
    $.foo    # Instance variable accessor
    $*foo    # Dynamically scoped variable
    $^foo    # A positional (placeholder) parameter to a block
    $:foo    # A named parameter
    $=foo    # POD (documentation) variables
    $?FILE   # Current source filename. The ? twigil indicates a compile-time value
    $~foo    # Sublanguage seen by parser, uncommon

=head3 [] Array indexing/slicing

Index and slice operations on arrays no longer inflect the variable's
L<sigil|#@_Array>, and adverbs can be used to control the type of slice:

=begin item
I<Indexing>

    puts months[2]; # Ruby
    say @months[2]; # Perl 6 - @ instead of $
=end item

=begin item
I<Value-slicing>

    puts months[8..11].join(',') # Ruby
    say @months[8..11].join(',') # Perl 6
=end item

Also note that the subscripting brackets are a normal postcircumfix operator
rather than a special syntactic form, and thus L<checking for existence of
elements|#exists> and L<unsetting elements|#delete> is done with adverbs.

=head3 {} Hash indexing/slicing

Ruby uses square brackets to access values for both Arrays and Hashes. Perl 6
uses curley braces for hashes instead. The angle-brackets version is available
which always autoquotes its contents (strings without quotes):

Adverbs can be used to control the type of slice.

=begin item
I<Indexing>

    puts calories["apple"]  # Ruby
    say %calories{"apple"}; # Perl 6 - % instead of $

    puts calories["apple"]  # Ruby
    puts calories[:apple]   # Ruby, symbols for keys are common
    say %calories<apple>;   # Perl 6 - angle brackets instead of single-quotes
    say %calories«$key»;    # Perl 6 - double angles interpolate as double-quotes
=end item

=begin item
I<Value-slicing>

    puts calories.values_at('pear', 'plum').join(',') # Ruby
    puts calories.values_at(%w(pear plum)).join(',')  # Ruby, pretty?
    say %calories{'pear', 'plum'}.join(',');          # Perl 6
    say %calories<pear plum>.join(',');               # Perl 6 (prettier)
    my $keys = 'pear plum';
    say %calories«$keys».join(','); # Perl 6, interpolated split
=end item

=begin item
I<Key/value-slicing>

    say calories.slice('pear', 'plum').join(','); # Ruby, with ActiveRecord
    say %calories{'pear', 'plum'}:kv.join(',');   # Perl 6 - use :kv adverb
    say %calories<pear plum>:kv.join(',');        # Perl 6 (prettier version)
=end item

Also note that the subscripting curly braces are a postcircumfix operator
rather than a special syntactic form, and thus L<checking for existence of
keys|#exists> and L<removing keys|#delete> is done with adverbs.

=head3 C<:> Symbols

Perl 6 generally uses strings in the places where Ruby uses symbols. A primary
example of this is in hash keys.

    address[:joe][:street] # Typical Ruby nested hash with symbol keys
    %address<joe><street>  # Typical Perl 6 nested hash with string keys

Just to be confusing, Perl 6 has I<colon-pair> syntax, which can sometimes look
like Ruby symbols.

    :age            # Ruby symbol
    :age            # Perl 6 pair with implicit True value
    :age(True)      # Perl 6 pair with explicit True value
    age => True     # Perl 6 pair using arrow notation
    "age" => True   # Perl 6 pair using arrow notation and explicit quotes

You could probably get away with using a colon-pair without an explicit value
and pretend that it is a Ruby symbol a lot of the time, but it is probably a
bad idea.

=head3 Variable Declaration and Scope

For local variables, Ruby uses implicit variable declaration upon assignment
and limited to the current block. Perl 6 uses explicit scope indicators, and
doesn't create variables implicitly. The commonly used declarations:

    foo = 7        # Ruby, variable scope is defined by first assignment
    my  $foo = 7   # Perl 6, lexical scoped to the current block
    our $foo = 7   # Perl 6, package scoped
    has $!foo = 7  # Perl 6, instance scoped (attribute)


=head2 Operators

See S03-operators for full details on all operators.

Unchanged:

=item C<,> List Separator
=item C<+> Numeric Addition
=item C<-> Numeric Subtraction
=item C<*> Numeric Multiplication
=item C</> Numeric Division
=item C<%> Numeric Modulus
=item C<**> Numeric Exponentiation
=item C<! && || ^> Booleans, high-precedence
=item C<not and or xor> Booleans, low-precedence
=item C«== != < > <= >=»   Numeric comparisons

=head3 C<++> Numeric Increment
=head3 C<--> Numeric Decrement

You may use C<$x++> instead of C<x += 1> as a shortcut for incrementing a
variable. This can be used as a pre-increment C<++$x> (increment, return new
value) or post-increment C<$x++> (increment, return old value).

You may use C<$x--> instead of C<x -= 1> as a shortcut for decrementing a
variable. This can be used as a pre-decrement C<--$x> (decrement, return new
value) or post-decrement C<$x--> (decrement, return old value).

=head3 C<eq ne lt gt le ge> String comparisons

String comparisions are separated from numeric comparisons to make explicit
what sort of comparison you are doing. Using C<==> tries to convert the values
to numbers, and C<eq> tries to convert the values to strings.

=head3 C«<=> leg» Three-way comparisons

In Ruby, the C«<=>» operator returns -1, 0, or 1.
In Perl 6, they return C<Order::Less>, C<Order::Same>, or C<Order::More>.

C«<=>» forces numeric context for the comparison.

C«leg» ("Less, Equal, or Greater?") forces string context for the comparison.

C«cmp» does either C«<=>» or C<leg>, depending on the existing type of its
arguments.

=head3 C<~~> Smart-match operator

This is a very common matching operator. Here are some examples:

    say "match!" if $foo ~~ /bar/;      # Regex match
    say "match!" if $foo ~~ "bar";      # String match
    say "match!" if $foo ~~ :(Int, Str) # Signature match (destructure)

See L<S03/Smart matching|https://design.perl6.org/S03.html#Smart_matching>

=head3 C<& | ^> Numeric Bitwise ops
=head3 C<& | ^> Boolean ops

In Perl 6, these single-character ops have been removed, and replaced by
two-character ops which coerce their arguments to the needed context.

    # Infix ops (two arguments; one on each side of the op)
    +&  +|  +^  And Or Xor: Numeric
    ~&  ~|  ~^  And Or Xor: String
    ?&  ?|  ?^  And Or Xor: Boolean

    # Prefix ops (one argument, after the op)
    +^  Not: Numeric
    ~^  Not: String
    ?^  Not: Boolean (same as the ! op)

=head3 C<&.> Conditional chaining operator

Ruby uses the C<&.> operator to chain methods without raising an error if one
invocation returns nil. In Perl 6 use C<.?> for that.

=head3 C«<< >>» Numeric shift left|right ops

Replaced by C«+<» and C«+>» .

    puts 42 << 3  # Ruby
    say  42 +< 3; # Perl 6

=head3 C«=>» and C<:> Key-Value Separators

In Ruby, C«=>» is used in the context of key/value pairs for Hash literal
declaration and parameter passing. C<:> is used as a shorthand when the left
side is a symbol.

In Perl 6, C«=>» is the Pair operator, which is quite different in
principle, but works the same in many situations.

If you were using C«=>» in hash initialization, or in passing arguments to a
method that expects named values or a hash, then the usage is very similar.

    # Works similarly in Ruby and Perl 6
    my %hash = ( AAA => 1, BBB => 2 );
    get_the_loot( 'diamonds', { quiet_level => 'very', quantity => 9 }); # Note the curly braces

=head3 C<? :> Ternary operator

Now spelled with two question marks instead of one question mark, and two
exclamation points instead of one colon.

    result     = (  score > 60 )  ? 'Pass'  : 'Fail'; # Ruby
    my $result = ( $score > 60 ) ?? 'Pass' !! 'Fail'; # Perl 6

=head3 C<+> String Concatenation

Replaced by the tilde.

Mnemonic: think of "stitching" together the two strings with needle and thread.

    $food = 'grape' + 'fruit'  # Ruby
    $food = 'grape' ~ 'fruit'; # Perl 6

=head3 String interpolation

In Ruby, C<"#{foo}s"> deliminates an arbitrary block embedded in the string.
In Perl 6 drop the C<#> prefix: C<"{$foo}s">

=head2 Compound Statements

=head3 Conditionals

=head4 C<if> C<elsif> C<else> C<unless>

Mostly unchanged; Binding the conditional expression to a variable is also a little different:

    if x = dostuff(); ...; end   # Ruby
    if dostuff() -> $x {...}     # Perl 6

The C<unless> conditional only allows for a single block in Perl 6;
it does not allow for an C<elsif> or C<else> clause.

=head4 C<given>-C<when>

The C<given>-C<when> construct is like a chain of C<if>-C<elsif>-C<else>
statements or like the C<switch>-C<case> construct in e.g. C. It has the
general structure:

    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        default { ... }
    }

In its simplest form, the construct is as follows:

    given $value {
        when "a match" {
            do-something();
        }
        when "another match" {
            do-something-else();
        }
        default {
            do-default-thing();
        }
    }

This is simple in the sense that a scalar value is matched in the C<when>
statements. More generally, the matches are actually smart-matches on the
input value such that lookups using more complex entities such as regexps
can be used instead of scalar values.

=head3 Loops

=head4 C<while> C<until>

Mostly unchanged; parens around the conditions are optional, but if used, must
not immediately follow the keyword, or it will be taken as a function call
instead. Binding the conditional expression to a variable is also a little
different:

    while x = dostuff(); ...; end    # Ruby
    while dostuff() -> $x {...}      # Perl 6

=head4 C<for> C<foreach>

Note first this common misunderstanding about the C<for> and C<foreach>
keywords. Many programmers think that they distinguish between the C-style
three-expression form and the list-iterator form; they do not! In fact,
they keywords are interchangeable; the Ruby compiler looks for the
semi-colons within the parens to determine which type of loop to parse.

The C-style three-factor form now uses the C<loop> keyword, and is
otherwise unchanged. The parens *are* still required.

    for  ( my $i = 1; $i <= 10; $i++ ) { ... } # Ruby
    loop ( my $i = 1; $i <= 10; $i++ ) { ... } # Perl 6


The loop-iterator form of C<for> or C<foreach> is named C<for> in Perl 6.
C<foreach> is no longer a keyword.
Parens are optional.

The iteration variable, if any, is after the list and an added arrow operator.

The iteration variable is always lexical; C<my> is neither needed nor
allowed.

In Ruby, the iteration variable is a copy of the list element, and modifying it does nothing to the original list. Note that it is a copy of the REFERENCE, so you can still change the values to which it refers.

In Perl 6, that alias is read-only (for safety) and thus behaves exactly like
Ruby, unless you change C«->» to C«<->».

    cars.each { |car| ... }    # Ruby; read-only referenc
    for @cars  -> $car   {...} # Perl 6; read-only
    for @cars <-> $car   {...} # Perl 6; read-write

=head3 Flow Control statements

Same as Ruby:

=item C<next>
=item C<redo>

=item4 C<break>

This is C<last> in Perl 6.

=head2 Regular Expressions ( Regex / Regexp )

=head3 C<=~> and C<!~> Operators, Matching

In Ruby, regex matches can be done against a variable using the C<=~> regexp
match operator or the C<.match> method. In Perl 6, the C<~~> smartmatch op is
used instead, or the C<.match> method.

    next if line   =~ /static/   # Ruby
    next if $line  ~~ /static/;  # Perl 6

    next if line  !~  /dynamic/ ; # Ruby
    next if $line !~~ /dynamic/ ; # Perl 6

    next if line.match(/static/)    # Ruby
    next if $line.match(/static/);  # Perl 6

Alternately, the C<.match> and C<.subst> methods can be used. Note that
C<.subst> is non-mutating. See
L<S05/Substitution|https://design.perl6.org/S05.html#Substitution>.

=head3 C<.sub> and C<.sub!>

In Perl 6 you typically use the C<s///> operator to do regex substitution.

    fixed = line.sub(/foo/, 'bar')     # Ruby, non-mutating
    $fixed = $line.subst(/foo/, 'bar') # Perl 6, non-mutating

    line.sub!(/foo/, 'bar')   # Ruby, mutating
    $line ~~ s/foo/bar/;      # Perl 6, mutating

=head3 Move regex options

Move any options from the end of the regex to the beginning. This may
require you to add the optional C<m> on a plain match like C«/abc/».

    next if $line =~    /static/i ; # Ruby
    next if $line ~~ m:i/static/  ; # Perl 6

=head3 Special matchers generally fall under the <> syntax

There are many cases of special matching syntax that Ruby regexes
support. They won't all be listed here, but often instead of being
surrounded by C<()>, the assertions will be surrounded by C«<>».

For character classes, this means that:

=item C<[abc]> becomes C«<[abc]>»

=item C<[^abc]> becomes C«<-[abc]>»

=item C<[a-zA-Z]> becomes C«<[a..zA..Z]>»

=item C<[[:upper:]]> becomes C«<:Upper>»

=item C<[abc[:upper:]]> becomes C«<[abc]+:Upper>»

For look-around assertions:

=item C<(?=[abc])> becomes C«<?[abc]>»

=item C<(?=ar?bitrary* pattern)> becomes C«<before ar?bitrary* pattern>»

=item C<(?!=[abc])> becomes C«<![abc]>»

=item C<(?!=ar?bitrary* pattern)> becomes C«<!before ar?bitrary* pattern>»

=item C«(?<=ar?bitrary* pattern)» becomes C«<after ar?bitrary* pattern>»

=item C«(?<!ar?bitrary* pattern)» becomes C«<!after ar?bitrary* pattern>»

(Unrelated to <> syntax, the "lookaround" C</foo\Kbar/> becomes C«/foo <( bar )> /»

=item C<(?(?{condition))yes-pattern|no-pattern)> becomes C«[ <?{condition}>
      yes-pattern | no-pattern ]»

=head3 Longest token matching (LTM) displaces alternation

In Perl 6 regexen, C<|> does LTM, which decides which alternation wins
an ambiguous match based off of a set of rules, rather than about which
was written first.

The simplest way to deal with this is just to change any C<|> in your
Ruby regex to a C<||>.

TODO more rules. Use L<< C<translate_regex.pl> from Blue
Tiger|https://github.com/Util/Blue_Tiger/ >> in the meantime.

=head2 Command-line flags

See
L<S19/commandline|https://design.perl6.org/S19.html#Command_Line_Elements>

=head2 File-related operations

=head3 Reading the lines of a text file into an array

In Ruby, one way of reading the lines of a text file goes
something like this:

    lines = File.readlines("file")   # Ruby
    my @lines = "file".IO.lines;     # Perl 6


In Perl 6, this has been simplified to

    my @lines = "file".IO.lines;

=head3 Iterating over the lines of a text file

Reading the entire file into memory isn't recommended. The C<.lines> method in
Perl6 returns a lazy sequence, but assigning to an array forces the file to be
read. It is better to iterate over the results:

    # Ruby
    File.foreach("file") do |line|
        puts line
    end

    # Perl 6
    for "file".IO.lines -> $line {
        say $line
    }

For both Ruby and Perl 6 the line comes with the newline already removed.

=head2 Environment variables

=head3 Perl module library path

In Ruby one of the environment variables to specify extra search paths for
modules is C<RUBYLIB>.

    $ RUBYLIB="/some/module/lib" ruby program.rb

In Perl 6 this is similar, one merely needs to change the name. As you probably
guessed, you just need to use C<PERL6LIB>:

    $ PERL6LIB="/some/module/lib" perl6 program.p6

As with Ruby, if you don't specify C<PERL6LIB>, you need to specify the
library path within the program via the C<use lib> pragma:

    use lib '/some/module/lib';

Note that C<PERL6LIB> is more of a developer convenience in Perl 6 (as
opposed to the equivalent usage of C<RUBYLIB> in Ruby) and shouldn't be
used by module consumers as it could be removed in the future. This is
because Perl 6's module loading isn't directly compatible with operating
system paths.

=head2 Misc.

=head3 Importing specific functions from a module

In Ruby there is no built-in way to selectively import/export methods from a
module.

In Perl 6 one specifies the functions which are to be exported by using the
C<is export> role on the relevant subs and I<all> subs with this role are
then exported. Hence, the following module C<Bar> exports the subs C<foo>
and C<bar> but not C<baz>:

    unit module Bar;

    sub foo($a) is export { say "foo $a" }
    sub bar($b) is export { say "bar $b" }
    sub baz($z) { say "baz $z" }

To use this module, simply C<use Bar> and the functions C<foo> and C<bar>
will be available

    use Bar;
    foo(1);    #=> "foo 1"
    bar(2);    #=> "bar 2"

If one tries to use C<baz> an "Undeclared routine" error is raised at compile time.

=head2 Core modules

=head4 C<OptionParser>

Switch parsing is now done by the parameter list of the C<MAIN> subroutine.

    # Ruby
    require 'optparse'
    options = {}
    OptionParser.new do |opts|
        opts.banner = 'Usage: example.rb --length=abc'
        opts.on("--length", "Set the file") do |length|
            raise "Length must be > 0" unless length.to_i > 0
            options[:length] = length
        end
        opts.on("--filename", "Set the file") do |filename|
            options[:file] = filename
        end
        opts.on("--verbose", "Increase verbosity") do |verbose|
            options[:verbose] = true
        end
    end.parse!

    puts options[:length]
    puts options[:filename]
    puts 'Verbosity ', (options[:verbose] ? 'on' : 'off')

    ruby example.rb --filename=foo --length=42 --verbose
        42
        foo
        Verbosity on

    ruby example.rb --length=abc
        Length must be > 0

    # Perl 6
    sub MAIN ( Int :$length where * > 0, :filename = 'file.dat', Bool :$verbose ) {
        say $length;
        say $data;
        say 'Verbosity ', ($verbose ?? 'on' !! 'off');
    }

    perl6 example.p6 --file=foo --length=42 --verbose
        42
        foo
        Verbosity on
    perl6 example.p6 --length=abc
        Usage:
          c.p6 [--length=<Int>] [--file=<Any>] [--verbose]

Note that Perl 6 auto-generates a full usage message on error in
command-line parsing.

=head2 Automated Translation

There are currently no automated transation tools from Ruby to Perl 6.

=end pod

=begin comments

### Guidelines for contributions:

Headers should contain the text that a Ruby user might search for, since
those headings will be in the Table of Contents generated for the top of
the document.

We use POD =item instead of =head3 or =head4 for unchanged bits that need
not appear in the TOC.

This article does not describe the additions to syntax, nor details of
possible improvements. For example, C<0 + $string> still works, even though
we would write it as C<+$string> now. (Blue Tiger will offer a Perl
Modernization guide, with step-by-step procedures for translation, along
with details of new idioms and "better ways to do it")

Example code and links to other documents should be favored over long
explanations of details better found elsewhere.

Finally, if a real user asks a Ruby->P6 question not answered here, please
add it to the document, even if we don't have a good answer yet. That will
be better than losing the information about a real need.

=end comments

